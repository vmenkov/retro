package edu.rutgers.retro;

//import org.apache.lucene.document.*;
//import org.apache.lucene.index.*;
//import org.apache.lucene.search.*;

import java.io.*;
import java.util.*;
import java.util.regex.*;
import java.text.*;

import org.json.*;

//import cern.colt.matrix.*;
//import cern.colt.matrix.impl.SparseDoubleMatrix2D;
//import cern.colt.matrix.linalg.SingularValueDecomposition;

/*
import edu.rutgers.axs.*;
import edu.rutgers.axs.indexer.*;
import edu.rutgers.axs.sql.*;
import edu.rutgers.axs.recommender.*;
*/

/** 
 */
public class Main {

    /** It seems to be more efficient to pre-compile the pattern than
	to do String.split() */
    private static final Pattern commaPattern = Pattern.compile(",");

    private static final Pattern datePattern = Pattern.compile("[0-9][0-9][0-9][0-9][0-9][0-9]");

    /** Checks input file date, if a range restriction has been requested 
     */
    private static boolean dateIsAcceptable(File f) {
	if (usageFrom==null && usageTo==null) return true; 
	//	e.g.    cs.110413_usage.csv
	Matcher m = datePattern.matcher(f.getName());
	if (!m.find()) {
	    System.out.println("Unable to find the date in the name of the file " + f + "; skipping the file");
	    return false;
	} 
	String d = m.group();
	if (usageFrom != null && d.compareTo(usageFrom) < 0) return false;
	if (usageTo != null && d.compareTo(usageTo) >= 0) return false;
	return true;
    }

    /** Reads split usage files for a particular category generated by DataSaver.
	All files found in the category's split file directory will be read;
	so make sure you have the correct selection of files there.
     */
    /*
    private static U2PL	readSplitFiles(String majorCat, ArxivUserInferrer inferrer) throws IOException {
	File dir = Json.catDir(majorCat);
	File[] files=dir.listFiles(); 
	Arrays.sort(files);
	U2PL   user2pageList = new U2PL();
	user2pageList.setArticleDateRange(articleDateFrom,  articleDateTo);

	for(File f: files) {

	    if (!dateIsAcceptable(f)){
		System.out.println("Skip file " + f );
		continue;
	    }

	    System.out.println("Reading split file " + f + ", at "+ new Date());
	    FileReader fr = new FileReader(f);
	    LineNumberReader r = new LineNumberReader(fr);
	    String s = null;
	    while((s=r.readLine())!=null) {
		s = s.trim();
		if (s.equals("")) continue;
		//		String q[] = s.split(",");
		String q[] = commaPattern.split(s);
		if (q.length!=3) throw new IOException("Could not parse line no. " + r.getLineNumber() + " in file " + f + " as an (ip,cookie,page) tuple:\n" + s);
		String user = inferrer.inferUser(q[0],q[1]);
		if (user==null) { 
		    // let's ignore no-cookie entries (which, actually,
		    // don't exist)
		} else {
		    String aid=q[2];
		    user2pageList.add(user, aid);
		}
	    }
	    r.close();
	}
	System.out.println( inferrer.report());
	System.out.println( "Ignored " +  user2pageList.ignoreCnt + " log entries for out-of-date-range articles");
	return user2pageList;
    }
    */
   
    static void usage() {
	usage(null);
    }

    static void usage(String m) {
	System.out.println("Usage: java edu.rutgers.retro.Main [split filename]");
	if (m!=null) {
	    System.out.println(m);
	}
	System.exit(1);
    }
  
    /** Strings such as "20100101" or "20120101", specifying the
	temporal range (d1 &le; date &lt; d2) of the user activity data that we
	use in the construction of the coaccess matrix. A null value
	means that we don't select based on that criterion.
     */
    static private String usageFrom=null, usageTo=null;

    static private Date articleDateFrom=null,  articleDateTo=null;

    /** Returns a string in the format "YYMMDD". We have the "reverse year 2000
	problem" here, meaning that dates before 2000 can't be represented :-)
     */
    private static String getDateStringOption(ParseConfig ht, String name) {
	String x= ht.getOption(name, null);
	if (x==null) return x;
	if (x!=null && x.equals("null")) return null;
	if (x.length()==6) return x;
	if (x.length()==8 && x.startsWith("20")) return x.substring(2);
	usage("Option " + name + " must be in the format YYMMDD or YYYYMMDD");
	return null;
    }
					      

    private static ParseConfig ht = null;
    public static void main(String [] argv) throws IOException, java.text.ParseException, JSONException {

	ht = new ParseConfig();

	final String tcPath = ht.getOption("tc", "/data/json/usage/tc.json.gz");
	final boolean useCookies=true;

	usageFrom=getDateStringOption(ht,"usageFrom");
	usageTo  =getDateStringOption(ht,"usageTo");

	articleDateFrom = ht.getOptionDate("articleDateFrom", "2010-01-01");
	articleDateTo = ht.getOptionDate("articleDateTo", "2012-01-01");

	//	System.out.println("Reading pre-split usage files dated " +
	//			   usageFrom + " to " + usageTo);

	if (argv.length < 1) {
	    usage("Command not specified");
	} else if (argv[0].equals("split")) {
	    // Split the original JSON files by major cat.
	    if (argv.length < 2) {
		usage("File name not specified");
	    }
	    // String fname = "../json/user_data_0/" + "100510_user_data.json";
	    //String fname = "../json/user_data/" + "110301_user_data.json";
	    String fname = argv[1];
	    Json.splitJsonFile(fname);
	} else {
	    usage();
	}
    }

}
